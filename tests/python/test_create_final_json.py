import os
import pytest
import sys
import json

# The scripts for this repo are in the script_dir.
# We want to import the functions we're testing from the script and add to PYTHONPATH.
# data_dir_name contains path to kraken reports needed for testing.
# We test against outputs generated by original Perl script.

this_file_dir = os.path.dirname(os.path.abspath(__file__))
data_dir_name = os.path.join('data', 'create-final-json')
data_dir = os.path.join(this_file_dir, data_dir_name)
# path to script we are testing
script_dir = os.path.join(this_file_dir, os.pardir, os.pardir, 'bin')
sys.path.insert(1, script_dir)
sys.dont_write_bytecode = True

import create_final_json

def test_non_existing_stats_file():
    # test non existing stats file
    args = [0, "nonexisting.json", os.path.join(data_dir_name, "test_species_in_sample.json")]
    with pytest.raises(SystemExit) as pytest_wrapped_e:
        create_final_json.process_requirements(args)
    assert pytest_wrapped_e.type == SystemExit
    assert str(pytest_wrapped_e.value) == 'ERROR: cannot find nonexisting.json'

def test_non_existing_report():
    # test non existing report
    args = [0, os.path.join(data_dir_name, "test_alignmentStats.json"), "nonexisting.json"]
    with pytest.raises(SystemExit) as pytest_wrapped_e:
        create_final_json.process_requirements(args)
    assert pytest_wrapped_e.type == SystemExit
    assert str(pytest_wrapped_e.value) == 'ERROR: cannot find nonexisting.json'

def test_empty_stats_file():
    # test for empty stats file
    args = [0, os.path.join(data_dir_name, "test_empty.json"), os.path.join(data_dir_name, "test_species_in_sample.json")]
    with pytest.raises(SystemExit) as pytest_wrapped_e:
        create_final_json.process_requirements(args)
    assert pytest_wrapped_e.type == SystemExit
    assert str(pytest_wrapped_e.value) == 'ERROR: %s is empty' %os.path.join(data_dir_name, "test_empty.json")

def test_empty_report_file():
    # test for empty report file
    args = [0, os.path.join(data_dir_name, "test_alignmentStats.json"), os.path.join(data_dir_name, "test_empty.json")]
    with pytest.raises(SystemExit) as pytest_wrapped_e:
        create_final_json.process_requirements(args)
    assert pytest_wrapped_e.type == SystemExit
    assert str(pytest_wrapped_e.value) == 'ERROR: %s is empty' %os.path.join(data_dir_name, "test_empty.json")

def test_mismatched_ids():
    # test for mismatched IDs
    args = [0, os.path.join(data_dir_name, "test_alignmentStats.json"), os.path.join(data_dir_name, "mismatched_species_in_sample.json")]
    with pytest.raises(SystemExit) as pytest_wrapped_e:
        create_final_json.process_requirements(args)
    assert pytest_wrapped_e.type == SystemExit
    assert str(pytest_wrapped_e.value) == "ERROR: the sample IDs of %s and %s are mismatched" %(os.path.join(data_dir_name, "test_alignmentStats.json"), os.path.join(data_dir_name, "mismatched_species_in_sample.json"))

# test reading and parsing data
def test_read_and_parse_stats_and_report():
    stats_json = 'test_alignmentStats.json'
    report_json = 'test_species_in_sample.json'
    out_json = 'test_report.json'

    with open(os.path.join(data_dir_name, out_json), 'r') as f:
        test_out_json = json.load(f) 
    got_parse = create_final_json.read_and_parse_input_files(os.path.join(data_dir_name, stats_json), os.path.join(data_dir_name, report_json))
    assert got_parse == test_out_json